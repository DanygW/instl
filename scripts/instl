#!/usr/local/bin/python

from __future__ import print_function

import sys
import os
import argparse
import yaml

import installItem

class cmd_line_options(object):
    def __init__(self):
        self.input_files = None
        self.out_file_option = None
        self.main_targets = None
        self.state_file_option = None
        self.run = False
    def __str__(self):
        retVal = ("input_files: {self.input_files}\nout_file_option: {self.out_file_option}\n"+
                "main_targets: {self.main_targets}\nstate_file_option: {self.state_file_option}\n"+
                "run: {self.run}\n").format(**vars())
        return retVal
                
class instl_state(object):
    def __init__(self):
        self.out_file_realpath = None
        self.install_items_map = {}
        self.install_definitions_map = {}
        self.install_instaruction_lines = []
        
    def init_from_cmd_line_options(self, cmd_line_options_obj):
        if cmd_line_options_obj.input_files:
            self.install_definitions_map["__INSTL_MAIN_INPUT_FILES__"] = list(cmd_line_options_obj.input_files)
        if cmd_line_options_obj.out_file_option:
            self.install_definitions_map["__INSTL_MAIN_OUT_FILE__"] = cmd_line_options_obj.out_file_option[0]
        if cmd_line_options_obj.main_targets:
            self.install_definitions_map["__INSTL_MAIN_INSTALL_TARGETS__"] = list(cmd_line_options_obj.main_targets)
        if cmd_line_options_obj.state_file_option:
            self.install_definitions_map["__INSTL_MAIN_STATE_FILE__"] = cmd_line_options_obj.state_file_option
        if cmd_line_options_obj.run:
            self.install_definitions_map["__INSTL_MAIN_RUN_INSTALLATION__"] = "yes"
        
    def write(self, fd):
        dumper = yaml.Dumper(fd,
            default_style=None,
            default_flow_style=None,
            canonical=None,
            indent=4,
            width=120,
            allow_unicode=None,
            line_break=os.linesep,
            encoding=None,
            explicit_start=None,
            explicit_end=None,
            version=None,
            tags=None)
        dumper.open()
        dumper.represent_mapping('!define', self.install_definitions_map, flow_style=None) 
        dumper.close()
        print(dumper)
        for def_name, def_value in self.install_definitions_map.iteritems():
            fd.write("{def_name}: {def_value}\n".format(**vars()))
        for item_name, item_value in self.install_items_map.iteritems():
            fd.write("{item_name}: {item_value}\n".format(**vars()))
            
def prepare_args_parser():
    def decent_convert_arg_line_to_args(self, arg_line):
        """ parse a file with options so that we do not have to write one sub-option
            per line.  Remove empty lines and comment lines and end of line comments.
            ToDo: handle quotes
        """
        line_no_whitespce = arg_line.strip()
        if line_no_whitespce and line_no_whitespce[0] != '#':
            for arg in line_no_whitespce.split():
                if not arg:
                    continue
                elif  arg[0] == '#':
                    break
                yield arg

    parser = argparse.ArgumentParser(description='instl: cross platform svn based installer',
                    prefix_chars='-+',
                    fromfile_prefix_chars='@',
                    formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    argparse.ArgumentParser.convert_arg_line_to_args = decent_convert_arg_line_to_args
    standard_options = parser.add_argument_group(description='standard arguments:')
    standard_options.add_argument('input_files',
                                nargs='*',
                                metavar='file(s)-to-process',
                                help="One or more files containing dependencies and defintions")
    standard_options.add_argument('--out','-o',
                                required=False,
                                nargs=1,
                                default="stdout",
                                metavar='path-to-output-file',
                                dest='out_file_option',
                                help="a file to write installtion instructions")
    standard_options.add_argument('--target','-t',
                                required=False,
                                nargs='+',
                                default=["MAIN_INSTALL"],
                                metavar='which-target-to-install',
                                dest='main_targets',
                                help="Target to create install instructions for")
    standard_options.add_argument('--run','-r',
                                required=False,
                                default=False,
                                action='store_true',
                                dest='run',
                                help="run the installtion instructions script, requires --out")
    standard_options.add_argument('--state','-s',
                                required=False,
                                nargs='?',
                                const="stdout",
                                metavar='path-to-state-file',
                                dest='state_file_option',
                                help="a file to write program state - good for debugging")
    return parser;

def read_command_line_options(prog_state, arglist=None):
    try:
        parser = prepare_args_parser()
        if not arglist:
            arglist=sys.argv[1:]
        name_space_obj = cmd_line_options()
        args = parser.parse_args(arglist, namespace=name_space_obj)
        print("name_space_obj:", name_space_obj)
        prog_state.init_from_cmd_line_options(name_space_obj)
    except Exception as ex:
        print(ex)
        raise
    return args

def read_input_files(prog_state):
    input_files = prog_state.install_definitions_map.get("__INSTL_MAIN_INPUT_FILES__")
    if input_files:
        for file_path in input_files:
            with open(file_path, "r") as file_fd:
                for a_node in yaml.compose_all(file_fd):
                    if a_node.tag == u'!define':
                        read_defines(prog_state, a_node)
                    elif a_node.tag == u'!install_map':
                        read_install_items_map(prog_state, a_node)
                    else:
                        print("Unknown tag", a_node.tag)

def read_defines(prog_state, a_node):
    print('!define')
    
def read_install_items_map(prog_state, a_node):
    prog_state.install_items_map.update(installItem.read_yaml_items_map(a_node))
    print('!install_map')
                
def create_intall_instructions(prog_state):
    install_targets = prog_state.install_definitions_map.get("__INSTL_MAIN_INSTALL_TARGETS__")
    if install_targets:
        for target in install_targets:
            prog_state.install_instaruction_lines.append("install {}".format(target))
     
def open_output_file(prog_state):
    retVal = None
    out_file = prog_state.install_definitions_map.get("__INSTL_MAIN_OUT_FILE__")
    if out_file:
        retVal = sys.stdout
        if out_file != "stdout":
            retVal = open(out_file, "w")
            prog_state.out_file_realpath = os.path.realpath(out_file)
            os.chmod(prog_state.out_file_realpath, 0744)
    return retVal

def close_output_file(prog_state, out_fd):
    if out_fd:
        out_fd.close()

def write_program_state(prog_state):
    state_file = prog_state.install_definitions_map.get("__INSTL_MAIN_STATE_FILE__")
    print("state_file:", state_file)
    if state_file:
        fd = sys.stdout
        if state_file != "stdout":
            fd = open(state_file, "w")
        prog_state.write(fd)
        fd.close()
    
def write_instl_instructions(prog_state, fd):
    fd.write("#!/bin/sh\n")
    fd.write(os.linesep.join(prog_state.install_instaruction_lines))
    fd.write("\nexit 0\n")

def run_instl_instructions(prog_state):
    if "__INSTL_MAIN_RUN_INSTALLATION__" in prog_state.install_definitions_map:
        from subprocess import Popen
        install_process = Popen(prog_state.out_file_realpath)
        stdout, stderr = install_process.communicate()
    
if __name__ == "__main__":
    nso = instl_state()
    args = read_command_line_options(nso)
    cmd_line_options = vars(nso)
    read_input_files(nso)
    create_intall_instructions(nso)
    out_fd = open_output_file(nso)
    write_instl_instructions(nso, out_fd)
    close_output_file(nso, out_fd)
    write_program_state(nso)
    run_instl_instructions(nso)
    


I have two python dictionaries which I want to write to a single yaml file, with two documents:
    
    definitions = {"one" : 1, "two" : 2, "tree" : 3}
    actions = {"run" : "yes", "print" : "no", "report" : "maybe"}

The yaml file should look like:

    --- !define
    one: 1
    two: 2
    tree: 3
    
    -- !action
    run: yes
    print: no
    report: maybe
    ...
    
Using PyYaml I did not find a clear way to do that. I'm sure there is a simple method, but digging into PyYaml documentation, only got me confused. Do I need a dumper, emitter, or what? And what type of output each of these types produces? Yaml text? yaml nodes? YAMLObject object? Anyway I would be greatfull for any clarifications.
